#!/usr/bin/env python2
# Hack for dynamic DNS IPSec Site-to-Site VPN
# This script should be scheduled to run periodically re-establish VPN on IP
# change.
# See https://blog.azureinfra.com/2018/12/31/usg-vpns-and-dynamic-ips/
#
# IKE Group is used to identify existing configuration entry. It can be found
# initially via `configure; show vpn ipsec site-to-site peer`
import urllib
import json
import sys
import argparse
import subprocess
import socket
import logging

LOGGER = logging.getLogger(__name__)


def flatten_config(config):
    rv = []
    for key, value in config.items():
        if isinstance(value, dict):
            for inner_key, inner_value in flatten_config(value):
                rv.append(([key] + inner_key, inner_value))
        else:
            rv.append(([key], value))
    return rv


def load_config(args):
    if args.config is None:
        result = subprocess.check_output(
            ['mca-ctrl', '-t', 'dump-cfg']).decode('utf8')
        return json.loads(result)

    elif args.config == '-':
        return json.load(sys.stdin)

    else:
        with open(args.config) as f:
            return json.load(f)


def get_entry(config, ike_group):
    for peer, config in config['vpn']['ipsec']['site-to-site']['peer'].items():
        if config['ike-group'] == ike_group:
            return (peer, config)

    raise Exception("No config found for IKE group: {}".format(ike_group))


def get_wan_address(no_ssl):
    proto = 'http' if no_ssl else 'https'
    url = proto + '://api.ipify.org/'
    f = urllib.urlopen(url)
    return f.read()


def main_impl(args):
    config = load_config(args)
    current_peer, conf_entry = get_entry(config, args.ike_group)
    current_local = conf_entry['local-address']

    new_peer_address = socket.gethostbyname(args.peer_domain)
    new_local_address = get_wan_address(args.no_ssl)

    if (not args.force and current_local == new_local_address and
            current_peer == new_peer_address):
        LOGGER.info("Nothing to do, everything up to date.")
        return

    LOGGER.info("Config outdated... Updating")
    LOGGER.info("Current peer: {}".format(current_peer))
    LOGGER.info("Current local: {}".format(current_local))
    LOGGER.info("New peer: {}".format(new_peer_address))
    LOGGER.info("New local: {}".format(new_local_address))

    new_entry = dict(conf_entry)
    new_entry['local-address'] = new_local_address
    new_entry['description'] = 'Generated by dyn-s2s-tool'

    def exec_command(*cmd):
        LOGGER.info(' '.join(cmd))

        if args.dryrun:
            return

        subprocess.check_call(
            ['/opt/vyatta/sbin/vyatta-cfg-cmd-wrapper'] + list(cmd))

    exec_command('begin')
    exec_command('delete', 'vpn', 'ipsec', 'site-to-site', 'peer',
                 current_peer)
    for key, value in flatten_config(new_entry):
        exec_command(*['set', 'vpn', 'ipsec', 'site-to-site', 'peer',
                       new_peer_address] + key + [value])

    exec_command('show', 'vpn', 'ipsec', 'site-to-site', 'peer',
                 new_peer_address)
    exec_command('commit')
    exec_command('save')
    exec_command('end')


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Dynamic DNS IPSec Hack')
    parser.add_argument(
        '--dryrun', '-d', help="dry run, don't commit changes",
        action='store_true')
    parser.add_argument(
        '--config', '-c', help="mca-ctrl config file to use (optional)")
    parser.add_argument(
        '--peer-domain', '-p', required=True,
        help='FQDN of the IPSec tunnel peer')
    parser.add_argument(
        '--ike-group', '-i', required=True,
        help='IKE Group identifier to update')
    parser.add_argument(
        '--hc-url', '-hc', help="healthchecks.io url to ping")
    parser.add_argument('--force', '-f', action='store_true')
    parser.add_argument('--no-ssl', action='store_true')

    args = parser.parse_args()

    logging.basicConfig()
    file_handler = logging.FileHandler('/var/log/dynamic-ipsec-tool.log')
    file_handler.setFormatter(logging.Formatter(
        '[%(asctime)s:%(name)s:%(levelname)s] %(message)s'))
    LOGGER.addHandler(file_handler)
    LOGGER.setLevel(logging.INFO)

    if args.hc_url:
        urllib.urlopen(args.hc_url + '/start')

    try:
        main_impl(args)
    except Exception as e:
        if args.hc_url:
            urllib.urlopen(args.hc_url + '/fail')
        
        LOGGER.exception("Fatal error in main loop")
        raise e

    if args.hc_url:
        urllib.urlopen(args.hc_url)
